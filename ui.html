<!DOCTYPE html>
<html>
<head>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 16px;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 12px;
    }
    h2 {
      margin: 0 0 12px 0;
      font-size: 14px;
      font-weight: 600;
    }
    .status {
      padding: 8px 12px;
      border-radius: 4px;
      margin-bottom: 12px;
      font-size: 11px;
    }
    .status.connected {
      background: #e6f7e6;
      color: #0d5f0d;
    }
    .status.disconnected {
      background: #ffe6e6;
      color: #8f0000;
    }
    .status.checking {
      background: #fff4e6;
      color: #8f5000;
    }
    button {
      width: 100%;
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      margin-bottom: 8px;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .primary {
      background: #0d99ff;
      color: white;
    }
    .primary:hover:not(:disabled) {
      background: #0b7fd9;
    }
    .secondary {
      background: #f0f0f0;
      color: #333;
    }
    .secondary:hover:not(:disabled) {
      background: #e0e0e0;
    }
    .device-info {
      font-size: 11px;
      color: #666;
      margin-bottom: 12px;
      padding: 6px;
      background: #f9f9f9;
      border-radius: 3px;
    }
    .error {
      color: #d00;
      font-size: 11px;
      margin-top: 8px;
    }
    .toggle-container {
      margin-bottom: 12px;
    }
    .toggle-label {
      display: block;
      font-size: 11px;
      font-weight: 500;
      margin-bottom: 6px;
      color: #333;
    }
    .toggle-switch {
      display: flex;
      background: #f0f0f0;
      border-radius: 4px;
      padding: 2px;
      position: relative;
    }
    .toggle-option {
      flex: 1;
      padding: 6px 12px;
      text-align: center;
      font-size: 11px;
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.2s;
      user-select: none;
      position: relative;
      z-index: 1;
    }
    .toggle-option.active {
      background: white;
      color: #0d99ff;
      font-weight: 500;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
  </style>
</head>
<body>
  <h2>ðŸ“± Mobile Screenshotter</h2>

  <div id="status" class="status checking">
    Checking server connection...
  </div>

  <div id="deviceInfo" class="device-info" style="display: none;">
    <div><strong><span id="deviceModel">-</span></strong></div>
    <div id="resolutionInfo" style="margin-top: 4px; display: none;">
      Physical: <span id="physicalRes">-</span> | Logical: <span id="logicalRes">-</span>
    </div>
  </div>

  <div class="toggle-container">
    <div class="toggle-label">Import Resolution</div>
    <div class="toggle-switch">
      <div class="toggle-option" data-value="physical">Physical</div>
      <div class="toggle-option active" data-value="logical">Logical</div>
    </div>
  </div>

  <button id="screenshot" class="primary" disabled>
    Take Screenshot
  </button>

  <button id="checkConnection" class="secondary">
    Check Connection
  </button>

  <div id="error" class="error" style="display: none;"></div>

  <script>
    const SERVER_URL = 'http://localhost:3000';
    const FETCH_TIMEOUT = 10000; // 10 second timeout for fetch requests

    // Fetch with timeout wrapper
    async function fetchWithTimeout(url, options = {}) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);
      try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(timeoutId);
        return response;
      } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
          throw new Error('Request timed out');
        }
        throw error;
      }
    }

    // Toggle switch functionality
    let importResolution = 'logical'; // Default to logical

    document.querySelectorAll('.toggle-option').forEach(option => {
      option.addEventListener('click', function() {
        document.querySelectorAll('.toggle-option').forEach(opt => opt.classList.remove('active'));
        this.classList.add('active');
        importResolution = this.getAttribute('data-value');
      });
    });

    // Check server and device status
    async function checkConnection() {
      const statusEl = document.getElementById('status');
      const deviceInfoEl = document.getElementById('deviceInfo');
      const deviceModelEl = document.getElementById('deviceModel');
      const resolutionInfoEl = document.getElementById('resolutionInfo');
      const physicalResEl = document.getElementById('physicalRes');
      const logicalResEl = document.getElementById('logicalRes');
      const screenshotBtn = document.getElementById('screenshot');
      const errorEl = document.getElementById('error');

      errorEl.style.display = 'none';
      statusEl.className = 'status checking';
      statusEl.textContent = 'Checking connection...';

      try {
        // Check server
        const healthRes = await fetchWithTimeout(`${SERVER_URL}/health`);
        if (!healthRes.ok) throw new Error('Server not responding');

        // Check device
        const deviceRes = await fetchWithTimeout(`${SERVER_URL}/device`);
        const deviceData = await deviceRes.json();

        if (deviceData.connected) {
          statusEl.className = 'status connected';
          statusEl.textContent = 'âœ“ Server running, device connected';
          deviceInfoEl.style.display = 'block';

          // Display manufacturer and model
          const deviceName = `${deviceData.manufacturer} ${deviceData.model}`;
          deviceModelEl.textContent = deviceName;

          screenshotBtn.disabled = false;

          // Fetch and display resolution info
          try {
            const resRes = await fetchWithTimeout(`${SERVER_URL}/resolution`);
            const resData = await resRes.json();
            if (resData.success) {
              resolutionInfoEl.style.display = 'block';
              physicalResEl.textContent = `${resData.physical.width}x${resData.physical.height}`;
              logicalResEl.textContent = `${resData.logical.width}x${resData.logical.height}`;
            }
          } catch (resError) {
            // Don't show resolution if fetch fails
            resolutionInfoEl.style.display = 'none';
          }
        } else {
          statusEl.className = 'status disconnected';
          statusEl.textContent = 'âœ— Server running, no device connected';
          deviceInfoEl.style.display = 'none';
          screenshotBtn.disabled = true;
          showError('Connect your device via USB (Android: enable USB debugging, iOS: trust computer)');
        }
      } catch (error) {
        statusEl.className = 'status disconnected';
        statusEl.textContent = 'âœ— Server not running';
        deviceInfoEl.style.display = 'none';
        screenshotBtn.disabled = true;
        showError('Start the server: cd server && npm install && npm start');
      }
    }

    function showError(message) {
      const errorEl = document.getElementById('error');
      errorEl.textContent = message;
      errorEl.style.display = 'block';
    }

    // Animated progress indicator
    let progressInterval = null;
    function startProgress(btn) {
      const stages = ['Capturing', 'Processing', 'Transferring'];
      let stageIndex = 0;
      let dots = 0;

      const update = () => {
        dots = (dots + 1) % 4;
        btn.textContent = stages[stageIndex] + '.'.repeat(dots || 1);
      };

      update();
      progressInterval = setInterval(() => {
        dots++;
        if (dots > 3) {
          dots = 1;
          stageIndex = Math.min(stageIndex + 1, stages.length - 1);
        }
        btn.textContent = stages[stageIndex] + '.'.repeat(dots);
      }, 400);
    }

    function stopProgress() {
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
    }

    // Take screenshot
    async function takeScreenshot() {
      const screenshotBtn = document.getElementById('screenshot');
      const errorEl = document.getElementById('error');

      errorEl.style.display = 'none';
      screenshotBtn.disabled = true;
      startProgress(screenshotBtn);

      try {
        const startTime = Date.now();
        console.log('[UI] ========== Taking screenshot ==========');

        // Take screenshot (resolution is included in headers)
        let fetchStart = Date.now();
        const response = await fetchWithTimeout(`${SERVER_URL}/screenshot`);
        console.log(`[UI] Network fetch: ${Date.now() - fetchStart}ms`);

        if (!response.ok) {
          throw new Error('Screenshot request failed');
        }

        // Get resolution from header (or fallback to separate fetch)
        const resolutionHeader = response.headers.get('X-Resolution');
        let resolutionData = resolutionHeader ? JSON.parse(resolutionHeader) : null;
        if (!resolutionData || !resolutionData.success) {
          const resResponse = await fetchWithTimeout(`${SERVER_URL}/resolution`);
          resolutionData = await resResponse.json();
          if (!resolutionData.success) {
            throw new Error(resolutionData.error || 'Failed to get resolution');
          }
        }

        // Get raw binary directly (no base64 decode needed)
        let processStart = Date.now();
        const arrayBuffer = await response.arrayBuffer();
        const bytes = new Uint8Array(arrayBuffer);
        console.log(`[UI] ArrayBuffer processing: ${Date.now() - processStart}ms (${(bytes.length / 1024).toFixed(0)} KB)`);

        // Determine sizing based on toggle
        const useLogicalSize = (importResolution === 'logical');

        // Send image data to plugin main thread
        console.log(`[UI] Sending to Figma plugin (elapsed: ${Date.now() - startTime}ms)`);
        parent.postMessage({
          pluginMessage: {
            type: 'create-screenshot',
            imageData: Array.from(bytes), // Convert to regular array for postMessage
            useLogicalSize: useLogicalSize,
            resolutionData: resolutionData,
            startTime: startTime  // Pass start time for end-to-end measurement
          }
        }, '*');

        stopProgress();
        screenshotBtn.textContent = 'âœ“ Done!';
        setTimeout(() => {
          screenshotBtn.textContent = 'Take Screenshot';
          screenshotBtn.disabled = false;
        }, 1000);
      } catch (error) {
        stopProgress();
        showError('Failed to take screenshot: ' + error.message);
        screenshotBtn.textContent = 'Take Screenshot';
        screenshotBtn.disabled = false;
      }
    }

    // Event listeners
    document.getElementById('screenshot').onclick = takeScreenshot;
    document.getElementById('checkConnection').onclick = checkConnection;

    // Check connection on load
    checkConnection();
  </script>
</body>
</html>
